{"version":3,"file":"AACTransport.js","sourceRoot":"","sources":["../../lib/transports/AACTransport.ts"],"names":[],"mappings":"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","sourcesContent":["// De-packetize RTP packets to re-create AAC High Bit Rate (hbr) Audio\n// Write Audio to a .aac file\n// By Roger Hardiman, October 2019\n\nimport RTSPClient from \"../RTSPClient\";\nimport { RTPPacket, BitStream } from \"../util\";\n\nimport * as transform from \"sdp-transform\";\nimport { Writable } from \"stream\";\n\ninterface Details {\n  codec: string;\n  mediaSource: transform.MediaDescription;\n  rtpChannel: number;\n  rtcpChannel: number;\n}\n\nexport default class AACTransport {\n  client: RTSPClient;\n  stream: Writable;\n\n  ObjectType = 0;\n  FrequencyIndex = 0;\n  ChannelConfiguration = 0;\n\n  constructor(client: RTSPClient, stream: Writable, details: Details) {\n    this.client = client;\n    this.stream = stream;\n\n    client.on(\"data\", (channel, data, packet) => {\n      if (channel == details.rtpChannel) {\n        this.processRTPPacket(packet);\n      }\n    });\n\n    // Process the SDP to get the parameters for the AAC audio\n    // \"profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3;config=1490\"\n    // @ts-ignore\n    let fmtp = details.mediaSource.fmtp[0];\n    const fmtpConfig = transform.parseParams(fmtp.config);\n\n    let bs = new BitStream();\n    bs.AddHexString(fmtpConfig[\"config\"].toString());\n\n    /***\n    5 bits: object type\n        if (object type == 31)\n        6 bits + 32: object type\n    4 bits: frequency index\n        if (frequency index == 15)\n        24 bits: frequency\n    4 bits: channel configuration\n    var bits: AOT Specific Config\n    ***/\n\n    // Read 5 bits\n    this.ObjectType = bs.Read(5);\n\n    // Read 4 bits\n    this.FrequencyIndex = bs.Read(4);\n\n    // Read 4 bits\n    this.ChannelConfiguration = bs.Read(4);\n  }\n\n  processRTPPacket(packet: RTPPacket) {\n    // RTP Payload for MPEG4-GENERIC consis of multiple blocks of data\n\n    // Each block has 3 parts\n    // Part 1 - Acesss Unit Header Length + Header\n    // Part 2 - Access Unit Auxiliary Data Length + Data (not used in AAC High Bitrate)\n    // Part 3 - Access Unit Audio Data\n\n    let rtp_payload = packet.payload;\n    let ptr = 0;\n    let audio_data = [];\n\n    while (true) {\n      if (ptr + 4 > rtp_payload.length) break; // 2 bytes for AU Header Length, 2 bytes of AU Header payload\n\n      // Get Size of the AU Header\n      let au_headers_length_bits =\n        (rtp_payload[ptr] << 8) + (rtp_payload[ptr + 1] << 0); // 16 bits\n      let au_headers_length = Math.ceil(au_headers_length_bits / 8.0);\n      ptr += 2;\n\n      // Examine the AU Header. Get the size of the AAC data\n      let aac_frame_size =\n        ((rtp_payload[ptr] << 8) + (rtp_payload[ptr + 1] << 0)) >> 3; // 13 bits\n      let aac_index_delta = rtp_payload[ptr + 1] & 0x03; // 3 bits\n      ptr += au_headers_length;\n\n      // extract the AAC block\n      if (ptr + aac_frame_size > rtp_payload.length) break; // not enough data to copy\n      audio_data.push(rtp_payload.slice(ptr, ptr + aac_frame_size));\n      ptr += aac_frame_size;\n    }\n\n    // Write Audio Data Transport Stream (adts) header\n    // followed by the AAC data\n    for (let x = 0; x < audio_data.length; x++) {\n      let data = audio_data[x];\n\n      let bs = new BitStream(); //TODO - we could cache the header bitstream\n\n      bs.AddValue(0xfff, 12); // (a) Start of data\n      bs.AddValue(0, 1); // (b) Version ID, 0 = MPEG4\n      bs.AddValue(0, 2); // (c) Layer always 2 bits set to 0\n      let protection_absent = 1;\n      bs.AddValue(protection_absent, 1); // (d) 1 = No CRC\n      bs.AddValue(this.ObjectType - 1, 2); // (e) MPEG Object Type / Profile, minus 1\n      bs.AddValue(this.FrequencyIndex, 4); // (f)\n      bs.AddValue(0, 1); // (g) private bit. Always zero\n      bs.AddValue(this.ChannelConfiguration, 3); // (h)\n      bs.AddValue(0, 1); // (i) originality\n      bs.AddValue(0, 1); // (j) home\n      bs.AddValue(0, 1); // (k) copyrighted id\n      bs.AddValue(0, 1); // (l) copyright id start\n      bs.AddValue(data.length + 7, 13); // (m) AAC data + size of the ASDT header\n      bs.AddValue(2047, 11); // (n) buffer fullness ???\n      let num_acc_frames = 1;\n      bs.AddValue(num_acc_frames - 1, 1); // (o) num of AAC Frames, minus 1\n\n      // If Protection was On [value=0], there would be a 16 bit CRC here\n      if (protection_absent == 0) bs.AddValue(0xabcd /*Calc CRC()*/, 16); // (p)\n\n      let header = bs.ToArray();\n\n      // write to the aac file\n      this.stream.write(header);\n      this.stream.write(data);\n    }\n  }\n}\n"]}